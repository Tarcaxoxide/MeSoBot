#include <main.hpp>
#include <Misskey_Wrapper.hpp>
#include <iostream>
#include <chrono>
#include <thread>
#include <cctype>
#include <stdlib.h>     /* srand, rand */
#include <time.h>       /* time */
#include <tools.hpp>
#include <LangaugeProcessing.hpp>


namespace PROGRAM_NAME{
    using namespace std::chrono_literals;
    std::deque<Misskey_Wrapper::key_pair> ResponseMatrix;


    void learn(std::string A,std::string B){
        if(A.size() < 1)return;
        if(B.size() < 1)return;
        to_lower(A);
        to_lower(B);
        for(size_t i=0;i<ResponseMatrix.size();i++){
            if(A == ResponseMatrix[i].Key)return;
        }
        ResponseMatrix.push_back({A,B});
        std::cout<<" /Learned\\ "<< "[\n"<< A<<":"<<B <<"\n]"<<std::endl;
    }

    
    
    size_t saySomethingRandomTriggerTimer=0;
    size_t saySomethingRandomTrigger=500;
    size_t minsaySomethingRandomTrigger=100;
    size_t maxsaySomethingRandomTrigger=1000;

    int main(Arguments_t Arguments){
        srand (time(NULL));
        Misskey_Wrapper::MisskeyBot_cl Bot("https://sub.domain.tld","Acct","ID");
        Misskey_Wrapper::RequestBody_st MSG;
        MSG.clear();MSG.Data.ApiKey="API_Token";
        

        saySomethingRandomTrigger=(rand() % maxsaySomethingRandomTrigger)+minsaySomethingRandomTrigger;
        
        std::string old_id,old_text;

        Sentence_st SC_Average("hello hi");

        int64_t average_sim=0;
        while(true){
            std::this_thread::sleep_for(500ms);
            Bot.notes.global_timeline(MSG);
            if(MSG.Data.id != old_id){
                std::string mention="";
                std::string A_Text="",B_Text="";
                {// Handle the normal replies
                    for(size_t i=0;i<MSG.Data.mentions_text.size();i++){
                        mention=MSG.Data.mentions_text[i];
                        if(Bot == mention && MSG.Data.userId != Bot.Id()){
                            
                            for(size_t a=mention.size()+1;a<MSG.Data.text.size();a++){
                                A_Text+=MSG.Data.text[a];
                            }
                            if(MSG.Data.replyId.size() > 1){
                                MSG.Data.noteId=MSG.Data.replyId;
                                Bot.notes.show(MSG);
                                for(size_t a=mention.size()+1;a<MSG.Data.text.size();a++){
                                    B_Text+=MSG.Data.text[a];
                                }
                            }else{
                                B_Text=A_Text;
                            }
                            to_lower(A_Text);
                            to_lower(B_Text);
                            Misskey_Wrapper::key_pair TestPair={A_Text,"\0"};
                            for(size_t i=0;i<ResponseMatrix.size();i++){
                                if(ResponseMatrix[i].Key == TestPair.Key)TestPair.Value=ResponseMatrix[i].Value;
                            }
                            if(TestPair.Key.size() > 0 && TestPair.Value != "\0" ){
                                MSG.Data.replyId=MSG.Data.id;
                                MSG.Data.text=TestPair.Value;
                                Bot.notes.create(MSG);
                            }else{
                                MSG.Data.replyId=MSG.Data.id;
                                MSG.Data.text=SC_Average.Random(3000);
                                Bot.notes.create(MSG);
                            }
                        }
                    }
                }// Handle the normal replies
                if(A_Text == "" && B_Text == "" && MSG.Data.userId != Bot.Id()){
                    std::string Iid=MSG.Data.id;
                    A_Text=MSG.Data.text;
                    if(MSG.Data.replyId.size() > 1){
                        MSG.Data.noteId=MSG.Data.replyId;
                        Bot.notes.show(MSG);
                        B_Text+=MSG.Data.text;
                    }
                    std::string B_Text_fixed,A_Text_fixed;
                    to_lower(B_Text);
                    to_lower(A_Text);
                    bool tb=false;
                    for(size_t i=0;i<B_Text.size();i++){
                        if(B_Text[i] == '@')tb=true;
                        if(B_Text[i] == ' ')tb=false;
                        if(!tb)B_Text_fixed+=B_Text[i];
                    }
                    tb=false;
                    for(size_t i=0;i<A_Text.size();i++){
                        if(B_Text[i] == '@')tb=true;
                        if(B_Text[i] == ' ')tb=false;
                        if(!tb)A_Text_fixed+=A_Text[i];
                    }
                    learn(B_Text_fixed,A_Text_fixed);
                    MSG.Data.id=Iid;
                    if(B_Text_fixed.size() == 0){
                        std::string its="";
                        bool itz=false;
                        for(size_t i=0;i<A_Text_fixed.size();i++){
                            if(A_Text_fixed[i] == '@')itz=true;
                            if(A_Text_fixed[i] == ' ')itz=false;
                            if(!itz){its+=A_Text_fixed[i];}
                        }
                        if(its.size() < 2)continue;
                        std::cout<<"added:" << "[\n"<<its<<"\n]"<<std::endl;
                        SC_Average.AddSentence(its);
                        GenerateGraph(SC_Average);
                    }
                }
            }

            { // end of message sets
                old_id=MSG.Data.id;
                MSG.clear();
            }
            saySomethingRandomTriggerTimer++;
            if(!(saySomethingRandomTriggerTimer%10)){
                std::cout<<"T-"<<(saySomethingRandomTrigger-saySomethingRandomTriggerTimer)<<std::endl;
            }
            if(saySomethingRandomTriggerTimer >= saySomethingRandomTrigger){
                saySomethingRandomTrigger=(rand() % maxsaySomethingRandomTrigger)+minsaySomethingRandomTrigger;
                saySomethingRandomTriggerTimer=0;
                MSG.Data.replyId=MSG.Data.id;
                std::string Said=SC_Average.Random(3000);
                MSG.Data.text=Said;
                MSG.Data.cw=std::string("something random:");
                Bot.notes.create(MSG);
                std::cout<<" /RandomPost\\ "<< "[\n"<<Said<<"\n]"<<std::endl;
                
            }
        }
        
        return 0;
    }
};